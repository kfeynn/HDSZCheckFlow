<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Castle.ActiveRecord</name>
    </assembly>
    <members>
        <member name="T:Castle.ActiveRecord.ActiveRecordAttribute">
            <summary>
            Associate meta information related to the
            desired table mapping.
            </summary>
            <example>
            <code>
            [ActiveRecord("tb_Order")]
            public class Order : ActiveRecordBase
            {
            }
            </code>
            </example>
            <remarks>
            If no table is specified, the class name 
            is used as table name
            </remarks>
        </member>
        <member name="T:Castle.ActiveRecord.BaseAttribute">
            <summary>
            Implement common properties shared by some
            attributes
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordAttribute.#ctor">
            <summary>
            Uses the class name as table name
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordAttribute.#ctor(System.String)">
            <summary>
            Associates the specified table with the target type
            </summary>
            <param name="table"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordAttribute.#ctor(System.String,System.String)">
            <summary>
            Associates the specified table and schema with the target type
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Table">
            <summary>
            Gets or sets the table name associated with the type
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Schema">
            <summary>
            Gets or sets the schema name associated with the type
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Proxy">
            <summary>
            Associates a proxy type with the target type
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.DiscriminatorColumn">
            <summary>
            Gets or sets the Discriminator column for
            a table inheritance modeling
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.DiscriminatorType">
            <summary>
            Gets or sets the column type (like string or integer)
            for the discriminator column
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.DiscriminatorValue">
            <summary>
            Gets or sets the value that represents the
            target class on the discriminator column
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Where">
            <summary>
            SQL condition to retrieve objects
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Lazy">
            <summary>
            Enable lazy loading for the type
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordSkip">
            <summary>
            Denotes that the specific class - 
            which is an <see cref="T:Castle.ActiveRecord.ActiveRecordBase"/> subclass
            should not be processed by the framework
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Any">
            <summary>
            Avoids the AnyAttribute.MetaValue problem
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.BelongsToAttribute">
            <summary>
            Maps a one to one association.
            </summary>
            <example>
            <code>
            public class Post : ActiveRecordBase
            {
            	...
            	
            	[BelongsTo("blogid")]
            	public Blog Blog
            	{
            		get { return _blog; }
            		set { _blog = value; }
            	}
            </code>
            </example>
            <remarks>
            Please note that the 'blogid' foreign key lies on the 'Post' table.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.BelongsToAttribute.#ctor(System.String)">
            <summary>
            Indicates a column to be used on the association
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.Type">
            <summary>
            Gets or sets the target type
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.Column">
            <summary>
            Gets or sets the column used by association (usually a foreign key
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.Cascade">
            <summary>
            Gets of sets the cascade behavior
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.OuterJoin">
            <summary>
            Gets of sets the outer join behavior
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.Update">
            <summary>
            Gets or sets the update behavior. 
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.Insert">
            <summary>
            Gets or sets the update behavior. 
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.NotNull">
            <summary>
            Indicates whether this association allows nulls.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.Unique">
            <summary>
            Indicates whehter this association is unique
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.CollectionIDAttribute">
            <summary>
            Used for a collection that requires a collection id.
            </summary>
            <example><code>
            public class Blog : ActiveRecordBase
            {
            	...
            	
            	[HasManyAndBelongs/HasMany]
            	[CollectionIDAttribute(CollectionIDAttribute.Native)]
            	public int Id
            	{
            		get { return _id; }
            		set { _id = value; }
            	}
            </code></example>
        </member>
        <member name="T:Castle.ActiveRecord.CompositeKeyAttribute">
            <summary>
            Decorates a class that implements <c>Equals()</c> and <c>GetHashCode()</c>,
            is <c>Serializable</c>,
            and has two or more <c>KeyPropertyAttribute</c> properties.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.FieldAttribute">
            <summary>
            Maps a standard column of the table.
            </summary>
            <example>
            In the following example, the column is also
            called 'name', so you don't have to specify.
            <code>
            public class Blog : ActiveRecordBase
            {
            	[Field]
            	string name;
            	
            	
            </code>
            </example>
        </member>
        <member name="T:Castle.ActiveRecord.HasAndBelongsToManyAttribute">
            <summary>
            Maps a many to many association with an association table.
            </summary>
            <example><code>
            public class Company : ActiveRecordBase
            {
              ...
              
              [HasAndBelongsToMany( typeof(Person), RelationType.Bag, Table="PeopleCompanies", Column="person_id", ColumnKey="company_id" )]
              public IList People
              {
              	get { return _people; }
              	set { _people = value; }
              }
            }
            </code></example>
            <remarks>The <see cref="P:Castle.ActiveRecord.HasAndBelongsToManyAttribute.ColumnKey"/> must specify the key on the 
            association table that points to the primary key of this class. In 
            the example, 'company_id' points to 'Company'.
            </remarks>
        </member>
        <member name="P:Castle.ActiveRecord.RelationAttribute.Sort">
            <summary>
            Only used with sets
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.RelationAttribute.Index">
            <summary>
            Only used with maps
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.RelationAttribute.IndexType">
            <summary>
            Only used with maps
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.HasManyAttribute">
            <summary>
            Maps a one to many association.
            </summary>
            <example><code>
            public class Blog : ActiveRecordBase
            {
            	...
            	
            	[HasMany(typeof(Post), RelationType.Bag, Key="Posts", Table="Posts", Column="blogid")]
            	public IList Posts
            	{
            		get { return _posts; }
            		set { _posts = value; }
            	}
            </code></example>
        </member>
        <member name="T:Castle.ActiveRecord.HiloAttribute">
            <summary>
            Used when a constraint requires a hilo algorithm 
            </summary>
            <example><code>
            public class Blog : ActiveRecordBase
            {
            	...
            	
            	[HasManyAndBelongs/HasMany,
            	CollectionID(CollectionIDAttribute.HiLo),
            	Hilo]
            	public int Id
            	{
            		get { return _id; }
            		set { _id = value; }
            	}
            </code></example>
        </member>
        <member name="T:Castle.ActiveRecord.JoinedBaseAttribute">
            <summary>
            Denotes that a class is the parent class of one or 
            more subclasses using a join
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.JoinedKeyAttribute">
            <summary>
            Used for joined subclasses.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.KeyPropertyAttribute">
            <summary>
            A key property for a composite key
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.PropertyAttribute">
            <summary>
            Maps a standard column of the table.
            </summary>
            <example>
            In the following example, the column is also
            called 'name', so you don't have to specify.
            <code>
            public class Blog : ActiveRecordBase
            {
            	...
            	
            	[Property]
            	public int Name
            	{
            		get { return _name; }
            		set { _name = value; }
            	}
            </code>
            To map a column name, use 
            <code>
            	[Property("blog_name")]
            	public int Name
            	{
            		get { return _name; }
            		set { _name = value; }
            	}
            </code>
            </example>
        </member>
        <member name="T:Castle.ActiveRecord.NestedAttribute">
            <summary>
            Maps properties of a child object to columns of the table 
            of a parent class.
            </summary>
            <example>
            The following code illustrates the use of a 
            nested <c>PostalAddress</c> class
            <code>
            	[ActiveRecord("Companies")]
            	public class Company : ActiveRecordBase
            	{
            		private int id;
            		private PostalAddress _address;
            	
            		public Company()
            		{
            		}
            	
            		public Company(string name)
            		{
            			this.name = name;
            		}
            	
            		[PrimaryKey]
            		public int Id
            		{
            			get { return id; }
            			set { id = value; }
            		}
            	
            		[Nested]
            		public PostalAddress Address
            		{
            			get { return _address; }
            			set { _address = value; }
            		}
            	}
            	
            	public class PostalAddress
            	{
            		private String _address;
            		private String _city;
            		private String _state;
            		private String _zipcode;
            	
            		[Property]
            		public String Address
            		{
            			get { return _address; }
            			set { _address = value; }
            		}
            	
            		[Property]
            		public String City
            		{
            			get { return _city; }
            			set { _city = value;}
            		}
            	
            		[Property]
            		public String State
            		{
            			get { return _state; }
            			set { _state = value; }
            		}
            	
            		[Property]
            		public String ZipCode
            		{
            			get { return _zipcode; }
            			set { _zipcode = value; }
            		}
            	}
            </code>
            </example>
        </member>
        <member name="T:Castle.ActiveRecord.OneToOneAttribute">
            <summary>
            Associates a foreign table where the current class
            and the target class share their primary key.
            </summary>
            <example>
            The following code exemplifies two classes that maps 
            to two tables sharing the primary key:
            <code>
            	[ActiveRecord("Employee")]
            	public class Employee : ActiveRecordBase
            	{
            		private int id;
            		private Award award;
            	
            		[PrimaryKey(PrimaryKeyType.Native, "EmployeeID")]
            		public int ID
            		{
            			get { return this.id; }
            			set { this.id = value; }
            		}
            	
            		[OneToOne]
            		public Award Award
            		{
            			get { return this.award; }
            			set { this.award = value; }
            		}
            	}
            	
            	[ActiveRecord("Award")]
            	public class Award : ActiveRecordBase
            	{
            		private Employee employee;
            		private int id;
            	
            		public Award()
            		{
            		}
            	
            		public Award(Employee employee)
            		{
            			this.employee = employee;
            		}
            	
            		[OneToOne]
            		public Employee Employee
            		{
            			get { return this.employee; }
            			set { this.employee = value; }
            		}
            	
            		[PrimaryKey(PrimaryKeyType.Foreign, "EmployeeID")]
            		public int ID
            		{
            			get { return this.id; }
            			set { this.id = value; }
            		}
            	
            		public static Award[] FindAll()
            		{
            			return ((Award[]) (ActiveRecordBase.FindAll(typeof(Award))));
            		}
            	
            		public static void DeleteAll()
            		{
            			ActiveRecordBase.DeleteAll( typeof(Award) );
            		}
            	}
            	Employee emp = new Employee();
            	emp.Name = "john doe";
            	emp.Save();
            	
            	Award award = new Award(emp);
            	award.Description = "Invisible employee";
            	award.Save();
            </code>
            </example>
            <remarks>
            Usually classes that uses the primary key
            generated elsewhere (foreign) uses the PrimaryKey attribute with the
            generator type <c>PrimaryKeyType.Foreign</c>
            </remarks>
        </member>
        <member name="T:Castle.ActiveRecord.PrimaryKeyAttribute">
            <summary>
            Indicates the property which is the primary key.
            </summary>
            <example><code>
            public class Blog : ActiveRecordBase
            {
            	...
            	
            	[PrimaryKey(PrimaryKeyType.Native)]
            	public int Id
            	{
            		get { return _id; }
            		set { _id = value; }
            	}
            </code></example>
        </member>
        <member name="P:Castle.ActiveRecord.PrimaryKeyAttribute.Params">
            <summary>
            Comma separated value of parameters to the generator
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Config.ActiveRecordSectionHandler">
            <summary>
            Reads the configuration from a entry 'activerecord'
            in the xml associated with the AppDomain
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Config.XmlConfigurationSource">
            <summary>
            Source of configuration based on Xml 
            source like files, streams or readers.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource">
            <summary>
            Usefull for test cases.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.IConfigurationSource">
            <summary>
            Abstracts the source of configuration for the framework.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.IConfigurationSource.GetConfiguration(System.Type)">
            <summary>
            Implementors should return an <see cref="T:Castle.Model.Configuration.IConfiguration"/> 
            instance
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Register(System.Type,Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Internally used
            </summary>
            <param name="arType"></param>
            <param name="model"></param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.GetModel(System.Type)">
            <summary>
            Internally used
            </summary>
            <param name="arType"></param>
            <returns></returns>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Key">
            <summary>
            Used only by joined subclasses
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.Config">
            <summary>
            I need this class to pass special configuration for the many-to-any
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.GraphConnectorVisitor">
            <summary>
            Connects <see cref="T:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel"/> with their parents 
            <see cref="T:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel"/>
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor">
            <summary>
            Traverse the tree checking the semantics of the relation and
            association. The goal is to raise clear exceptions if tips of how 
            to fix any error.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor">
            <summary>
            Traverse the tree emitting proper xml configuration
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Scopes.AbstractScope">
            <summary>
            Abstract <seealso cref="T:Castle.ActiveRecord.ISessionScope"/> implementation
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.ISessionScope">
            <summary>
            Contract for implementation of scopes.
            </summary>
            <remarks>
            A scope can implement a logic that affects 
            AR for the scope lifetime. Session cache and
            transaction are the best examples, but you 
            can create new scopes adding new semantics.
            <para>
            The methods on this interface are mostly invoked
            by the <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder"/>
            implementation
            </para>
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.ISessionScope.RegisterSession(System.Object,NHibernate.ISession)">
            <summary>
            This method is invoked when no session was available
            at and the <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder"/>
            just created one. So it registers the session created 
            within this scope using a key. The scope implementation
            shouldn't make any assumption on what the key
            actually is as we reserve the right to change it 
            <seealso cref="M:Castle.ActiveRecord.ISessionScope.IsKeyKnown(System.Object)"/>
            </summary>
            <param name="key">an object instance</param>
            <param name="session">An instance of <c>ISession</c></param>
        </member>
        <member name="M:Castle.ActiveRecord.ISessionScope.IsKeyKnown(System.Object)">
            <summary>
            This method is invoked when the 
            <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder"/>
            instance needs a session instance. Instead of creating one it interrogates
            the active scope for one. The scope implementation must check if it
            has a session registered for the given key. 
            <seealso cref="M:Castle.ActiveRecord.ISessionScope.RegisterSession(System.Object,NHibernate.ISession)"/>
            </summary>
            <param name="key">an object instance</param>
            <returns><c>true</c> if the key exists within this scope instance</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ISessionScope.GetSession(System.Object)">
            <summary>
            This method should return the session instance associated with the key.
            </summary>
            <param name="key">an object instance</param>
            <returns>the session instance or null if none was found</returns>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Scopes.AbstractThreadScopeInfo">
            <summary>
            Base <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo"/> implementation. It's up 
            to derived classes to provide a correct implementation 
            of <c>CurrentStack</c> only
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope">
            <summary>
            Still very experimental and it's not bullet proof
            for all situations
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope.PerformDisposal(System.Collections.ICollection)">
            <summary>
            </summary>
            <param name="sessions"></param>
        </member>
        <member name="T:Castle.ActiveRecord.SessionScope">
            <summary>
            Implementation of <see cref="T:Castle.ActiveRecord.ISessionScope"/> to 
            augment performance by caching the session, thus
            avoiding too much opens/flushes/closes.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Scopes.ThreadScopeAccessor">
            <summary>
            Class to allow scopes to reach the implementation
            of <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo"/>. Also implements 
            the <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo"/> delegating the calls to 
            the scope set.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.TransactionMode">
            <summary>
            Defines the transaction scope behavior
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.TransactionMode.Inherits">
            <summary>
            Inherits a transaction previously create on 
            the current context.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.TransactionMode.New">
            <summary>
            Always create an isolated transaction context.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.TransactionScope">
            <summary>
            Implementation of <see cref="T:Castle.ActiveRecord.ISessionScope"/> to 
            provide transaction semantics
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Validators.AbstractValidator">
            <summary>
            Abstract <see cref="T:Castle.ActiveRecord.Framework.IValidator"/> implementation
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.IValidator">
            <summary>
            Define the basic contract for validators
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.IValidator.Initialize(System.Reflection.PropertyInfo)">
            <summary>
            Implementors should perform any initialization logic
            </summary>
            <param name="property">The target property</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.IValidator.Perform(System.Object)">
            <summary>
            Implementors should perform the actual validation upon
            the property value
            </summary>
            <param name="instance"></param>
            <returns><c>true</c> if the field is OK</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.IValidator.Perform(System.Object,System.Object)">
            <summary>
            Implementors should perform the actual validation upon
            the property value
            </summary>
            <param name="instance"></param>
            <param name="fieldValue"></param>
            <returns><c>true</c> if the field is OK</returns>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.IValidator.Property">
            <summary>
            The target property
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.IValidator.ErrorMessage">
            <summary>
            The error message to be displayed if the validation fails
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Validators.AbstractValidator.Initialize(System.Reflection.PropertyInfo)">
            <summary>
            Implementors should perform any initialization logic
            </summary>
            <param name="property">The target property</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Validators.AbstractValidator.Perform(System.Object)">
            <summary>
            Implementors should perform the actual validation upon
            the property value
            </summary>
            <param name="instance"></param>
            <returns><c>true</c> if the field is OK</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Validators.AbstractValidator.Perform(System.Object,System.Object)">
            <summary>
            Implementors should perform the actual validation upon
            the property value
            </summary>
            <param name="instance"></param>
            <param name="fieldValue"></param>
            <returns><c>true</c> if the field is OK</returns>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Validators.AbstractValidator.Property">
            <summary>
            The target property
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Validators.AbstractValidator.ErrorMessage">
            <summary>
            The error message to be displayed if the validation fails
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Validators.EmailValidator">
            <summary>
            
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.Validators.EmailValidator.emailRule">
            <summary>
            From http://www.codeproject.com/aspnet/Valid_Email_Addresses.asp
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Validators.NullCheckValidator">
            <summary>
            Ensures that a property was 
            filled with some value
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.NHibernateDelegate">
            <summary>
            Allow custom executions using the NHibernate's ISession.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordBase">
            <summary>
            Base class for all ActiveRecord classes. Implements 
            all the functionality to simplify the code on the 
            subclasses.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.BeforeSave(System.Collections.IDictionary)">
            <summary>
            Hook to change the object state
            before saving it.
            </summary>
            <param name="state"></param>
            <returns>Return <c>true</c> if you have changed the state. <c>false</c> otherwise</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.BeforeLoad(System.Collections.IDictionary)">
            <summary>
            Hook to transform the read data 
            from the database before populating 
            the object instance
            </summary>
            <param name="adapter"></param>
            <returns>Return <c>true</c> if you have changed the state. <c>false</c> otherwise</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.BeforeDelete(System.Collections.IDictionary)">
            <summary>
            Hook to perform additional tasks 
            before removing the object instance representation
            from the database.
            </summary>
            <param name="adapter"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.#ctor">
            <summary>
            Constructs an ActiveRecordBase subclass.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Register(System.Type,Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Internally used
            </summary>
            <param name="arType"></param>
            <param name="model"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.GetModel(System.Type)">
            <summary>
            Internally used
            </summary>
            <param name="arType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Execute(System.Type,Castle.ActiveRecord.NHibernateDelegate,System.Object)">
            <summary>
            Invokes the specified delegate passing a valid 
            NHibernate session. Used for custom NHibernate queries.
            </summary>
            <param name="targetType">The target ActiveRecordType</param>
            <param name="call">The delegate instance</param>
            <param name="instance">The ActiveRecord instance</param>
            <returns>Whatever is returned by the delegate invocation</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindByPrimaryKey(System.Type,System.Object,System.Boolean)">
            <summary>
            Finds an object instance by a unique ID
            </summary>
            <param name="targetType">The AR subclass type</param>
            <param name="id">ID value</param>
            <param name="throwOnNotFound"><c>true</c> if you want to catch an exception 
            if the object is not found</param>
            <returns></returns>
            <exception cref="T:NHibernate.ObjectNotFoundException">if <c>throwOnNotFound</c> is set to 
            <c>true</c> and the row is not found</exception>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindByPrimaryKey(System.Type,System.Object)">
            <summary>
            Finds an object instance by a unique ID
            </summary>
            <param name="targetType">The AR subclass type</param>
            <param name="id">ID value</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindAll(System.Type)">
            <summary>
            Returns all instances found for the specified type.
            </summary>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.SlicedFindAll(System.Type,System.Int32,System.Int32,NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.SlicedFindAll(System.Type,System.Int32,System.Int32,NHibernate.Expression.ICriterion[])">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindAll(System.Type,NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
            <summary>
            Returns all instances found for the specified type 
            using sort orders and criterias.
            </summary>
            <param name="targetType"></param>
            <param name="orders"></param>
            <param name="criterias"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindAll(System.Type,NHibernate.Expression.ICriterion[])">
            <summary>
            Returns all instances found for the specified type 
            using criterias.
            </summary>
            <param name="targetType"></param>
            <param name="criterias"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindAllByProperty(System.Type,System.String,System.Object)">
            <summary>
            Finds records based on a property value
            </summary>
            <remarks>
            Contributed by someone on the forum
            http://forum.castleproject.org/posts/list/300.page
            </remarks>
            <param name="targetType">The target type</param>
            <param name="property">A property name (not a column name)</param>
            <param name="value">The value to be equals to</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindAllByProperty(System.Type,System.String,System.String,System.Object)">
            <summary>
            Finds records based on a property value
            </summary>
            <param name="targetType">The target type</param>
            <param name="orderByColumn">The column name to be ordered ASC</param>
            <param name="property">A property name (not a column name)</param>
            <param name="value">The value to be equals to</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindFirst(System.Type,NHibernate.Expression.ICriterion[])">
            <summary>
            Searches and returns the first row.
            </summary>
            <param name="targetType">The target type</param>
            <param name="criterias">The criteria expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindFirst(System.Type,NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
            <summary>
            Searches and returns the first row.
            </summary>
            <param name="targetType">The target type</param>
            <param name="orders">The sort order - used to determine which record is the first one</param>
            <param name="criterias">The criteria expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindOne(System.Type,NHibernate.Expression.ICriterion[])">
            <summary>
            Searches and returns the a row. If more than one is found, 
            throws <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordException"/>
            </summary>
            <param name="targetType">The target type</param>
            <param name="criterias">The criteria expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Save(System.Object)">
            <summary>
            Saves the instance to the database
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Create(System.Object)">
            <summary>
            Creates (Saves) a new instance to the database.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Update(System.Object)">
            <summary>
            Persists the modification on the instance
            state to the database.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Delete(System.Object)">
            <summary>
            Deletes the instance from the database.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Execute(Castle.ActiveRecord.NHibernateDelegate)">
            <summary>
            Invokes the specified delegate passing a valid 
            NHibernate session. Used for custom NHibernate queries.
            </summary>
            <param name="call">The delegate instance</param>
            <returns>Whatever is returned by the delegate invocation</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Save">
            <summary>
            Saves the instance information to the database.
            May Create or Update the instance depending 
            on whether it has a valid ID.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Create">
            <summary>
            Creates (Saves) a new instance to the database.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Update">
            <summary>
            Persists the modification on the instance
            state to the database.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Delete">
            <summary>
            Deletes the instance from the database.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordMediator">
            <summary>
            Allow programmers to use the 
            ActiveRecord functionality without direct reference
            to <see cref="T:Castle.ActiveRecord.ActiveRecordBase"/>
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Execute(System.Type,Castle.ActiveRecord.NHibernateDelegate,System.Object)">
            <summary>
            Invokes the specified delegate passing a valid 
            NHibernate session. Used for custom NHibernate queries.
            </summary>
            <param name="targetType">The target ActiveRecordType</param>
            <param name="call">The delegate instance</param>
            <param name="instance">The ActiveRecord instance</param>
            <returns>Whatever is returned by the delegate invocation</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindByPrimaryKey(System.Type,System.Object,System.Boolean)">
            <summary>
            Finds an object instance by a unique ID
            </summary>
            <param name="targetType">The AR subclass type</param>
            <param name="id">ID value</param>
            <param name="throwOnNotFound"><c>true</c> if you want to catch an exception 
            if the object is not found</param>
            <returns></returns>
            <exception cref="T:NHibernate.ObjectNotFoundException">if <c>throwOnNotFound</c> is set to 
            <c>true</c> and the row is not found</exception>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindByPrimaryKey(System.Type,System.Object)">
            <summary>
            Finds an object instance by a unique ID
            </summary>
            <param name="targetType">The AR subclass type</param>
            <param name="id">ID value</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindAll(System.Type)">
            <summary>
            Returns all instances found for the specified type.
            </summary>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.SlicedFindAll(System.Type,System.Int32,System.Int32,NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.SlicedFindAll(System.Type,System.Int32,System.Int32,NHibernate.Expression.ICriterion[])">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindAll(System.Type,NHibernate.Expression.Order[],NHibernate.Expression.ICriterion[])">
            <summary>
            Returns all instances found for the specified type 
            using sort orders and criterias.
            </summary>
            <param name="targetType"></param>
            <param name="orders"></param>
            <param name="criterias"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindAll(System.Type,NHibernate.Expression.ICriterion[])">
            <summary>
            Returns all instances found for the specified type 
            using criterias.
            </summary>
            <param name="targetType"></param>
            <param name="criterias"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Save(System.Object)">
            <summary>
            Saves the instance to the database
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Create(System.Object)">
            <summary>
            Creates (Saves) a new instance to the database.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Update(System.Object)">
            <summary>
            Persists the modification on the instance
            state to the database.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Delete(System.Object)">
            <summary>
            Deletes the instance from the database.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.GetSessionFactoryHolder">
            <summary>
            Testing hock only.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordStarter">
            <summary>
            Performs the framework initialization.
            </summary>
            <remarks>
            This class is not thread safe.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.Initialize(Castle.ActiveRecord.Framework.IConfigurationSource,System.Type[])">
            <summary>
            Initialize the mappings using the configuration and 
            the list of types
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.Initialize(System.Reflection.Assembly,Castle.ActiveRecord.Framework.IConfigurationSource)">
            <summary>
            Initialize the mappings using the configuration and 
            checking all the types on the specified <c>Assembly</c>
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.Initialize(System.Reflection.Assembly[],Castle.ActiveRecord.Framework.IConfigurationSource)">
            <summary>
            Initialize the mappings using the configuration and 
            checking all the types on the specified Assemblies
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.Initialize">
            <summary>
            Initializes the framework reading the configuration from
            the <c>AppDomain</c> and checking all the types on the executing <c>Assembly</c>
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.CreateSchema">
            <summary>
            Generates and executes the creation scripts for the database.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.CreateSchemaFromFile(System.String)">
            <summary>
            Executes the specified script to create/drop/change the database schema
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.CreateSchemaFromFile(System.String,System.Data.IDbConnection)">
            <summary>
            Executes the specified script to create/drop/change the database schema
            against the specified database connection
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.DropSchema">
            <summary>
            Generates and executes the Drop scripts for the database.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.GenerateDropScripts(System.String)">
            <summary>
            Generates and executes the drop scripts for the database.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.GenerateCreationScripts(System.String)">
            <summary>
            Generates the creation scripts for the database
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.IsActiveRecordType(System.Type)">
            <summary>
            Return true if the type has a [ActiveRecord] attribute
            </summary>
        </member>
        <member name="E:Castle.ActiveRecord.ActiveRecordStarter.SessionFactoryHolderCreated">
            <summary>
            So others frameworks can intercept the 
            creation and act on the holder instance
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordValidationBase">
            <summary>
            Extends <see cref="T:Castle.ActiveRecord.ActiveRecordBase"/> adding automatic validation support.
            <seealso cref="M:Castle.ActiveRecord.ActiveRecordValidationBase.IsValid"/>
            </summary>
            <example>
            <code>
            public class Customer : ActiveRecordBase
            {
            	...
            	
            	[Property, ValidateNotEmpty]
            	public int Name
            	{
            		get { return _name; }
            		set { _name = value; }
            	}
            	
            	[Property, ValidateNotEmpty, ValidateEmail]
            	public int Email
            	{
            		get { return _email; }
            		set { _email = value; }
            	}
            </code>
            </example>
        </member>
        <member name="F:Castle.ActiveRecord.ActiveRecordValidationBase.__validators">
            <summary>
            List of validators that should be executed for this class
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.ActiveRecordValidationBase._errorMessages">
            <summary>
            List of error messages
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase.#ctor">
            <summary>
            Constructs an ActiveRecordValidationBase
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase.CollectValidators(System.Type)">
            <summary>
            Collect the validations applied to this class properties.
            </summary>
            <param name="targetType"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase.IsValid">
            <summary>
            Performs the fields validation. Returns true if no 
            validation error was found.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase.Save">
            <summary>
            Saves the instance information to the database.
            May Create or Update the instance depending 
            on whether it has a valid ID.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase.Create">
            <summary>
            Creates (Saves) a new instance to the database.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase.Update">
            <summary>
            Persists the modification on the instance
            state to the database.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase.OnNotValid">
            <summary>
            Throws an exception explaining why the save or update
            cannot be executed when fields are not ok to pass.
            </summary>
            <remarks>
            You can override this method to declare a better behavior.
            </remarks>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordValidationBase.ValidationErrorMessages">
            <summary>
            Returns a list of current validation errors messages.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordValidationBase.PropertiesValidationErrorMessage">
            <summary>
            Maps a specific PropertyInfo to a list of
            error messages. Useful for frameworks.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.ARSchemaCreator">
            <summary>
            Used to execute a script file to create/update/drop 
            a database schema. Inspired on NHibernate SchemaExport class.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.DictionaryAdapter">
            <summary>
            Maps keys to position in the values array. 
            Basically key -> index
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.HookDispatcher">
            <summary>
            Translates the <c>IInterceptor</c>
            messages to instance possible hooks
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.OnLoad(System.Object,System.Object,System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called just before an object is initialized
            </summary>
            <param name="entity"></param>
            <param name="id"></param>
            <param name="propertyNames"></param>
            <param name="state"></param>
            <param name="types"></param>
            <remarks>
            The interceptor may change the <c>state</c>, which will be propagated to the persistent
            object. Note that when this method is called, <c>entity</c> will be an empty
            uninitialized instance of the class.</remarks>
            <returns><c>true</c> if the user modified the <c>state</c> in any way</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.OnFlushDirty(System.Object,System.Object,System.Object[],System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called when an object is detected to be dirty, during a flush.
            </summary>
            <param name="currentState"></param>
            <param name="entity"></param>
            <param name="id"></param>
            <param name="previousState"></param>
            <param name="propertyNames"></param>
            <param name="types"></param>
            <remarks>
            The interceptor may modify the detected <c>currentState</c>, which will be propagated to
            both the database and the persistent object. Note that all flushes end in an actual
            synchronization with the database, in which as the new <c>currentState</c> will be propagated
            to the object, but not necessarily (immediately) to the database. It is strongly recommended
            that the interceptor <b>not</b> modify the <c>previousState</c>.
            </remarks>
            <returns><c>true</c> if the user modified the <c>currentState</c> in any way</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.OnSave(System.Object,System.Object,System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called before an object is saved
            </summary>
            <param name="entity"></param>
            <param name="id"></param>
            <param name="propertyNames"></param>
            <param name="state"></param>
            <param name="types"></param>
            <remarks>
            The interceptor may modify the <c>state</c>, which will be used for the SQL <c>INSERT</c>
            and propagated to the persistent object
            </remarks>
            <returns><c>true</c> if the user modified the <c>state</c> in any way</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.OnDelete(System.Object,System.Object,System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called before an object is deleted
            </summary>
            <param name="entity"></param>
            <param name="id"></param>
            <param name="propertyNames"></param>
            <param name="state"></param>
            <param name="types"></param>
            <remarks>
            It is not recommended that the interceptor modify the <c>state</c>.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.PreFlush(System.Collections.ICollection)">
            <summary>
            Called before a flush
            </summary>
            <param name="entities">The entities</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.PostFlush(System.Collections.ICollection)">
            <summary>
            Called after a flush that actually ends in execution of the SQL statements required to
            synchronize in-memory state with the database.
            </summary>
            <param name="entities">The entitites</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.IsUnsaved(System.Object)">
            <summary>
            Called when a transient entity is passed to <c>SaveOrUpdate</c>.
            </summary>
            <remarks>
            The return value determines if the object is saved
            <list>
            	<item><c>true</c> - the entity is passed to <c>Save()</c>, resulting in an <c>INSERT</c></item>
            	<item><c>false</c> - the entity is passed to <c>Update()</c>, resulting in an <c>UPDATE</c></item>
            	<item><c>null</c> - Hibernate uses the <c>unsaved-value</c> mapping to determine if the object is unsaved</item>
            </list>
            </remarks>
            <param name="entity">A transient entity</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.FindDirty(System.Object,System.Object,System.Object[],System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called from <c>Flush()</c>. The return value determines whether the entity is updated
            </summary>
            <remarks>
            	<list>
            		<item>an array of property indicies - the entity is dirty</item>
            		<item>an empty array - the entity is not dirty</item>
            		<item><c>null</c> - use Hibernate's default dirty-checking algorithm</item>
            	</list>
            </remarks>
            <param name="entity">A persistent entity</param>
            <param name="currentState"></param>
            <param name="id"></param>
            <param name="previousState"></param>
            <param name="propertyNames"></param>
            <param name="types"></param>
            <returns>An array of dirty property indicies or <c>null</c> to choose default behavior</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.Instantiate(System.Type,System.Object)">
            <summary>
            Instantiate the entity class. Return <c>null</c> to indicate that Hibernate should use the default
            constructor of the class
            </summary>
            <param name="type">A mapped type</param>
            <param name="id">The identifier of the new instance</param>
            <returns>An instance of the class, or <c>null</c> to choose default behaviour</returns>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder">
            <summary>
            Keeps an association of SessionFactories to a object model 
            tree;
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.Register(System.Type,NHibernate.Cfg.Configuration)">
            <summary>
            Associates a Configuration object to a root type
            </summary>
            <param name="rootType"></param>
            <param name="cfg"></param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.GetAllConfigurations">
            <summary>
            Pendent
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.GetConfiguration(System.Type)">
            <summary>
            Requests the Configuration associated to the type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.GetSessionFactory(System.Type)">
            <summary>
            Obtains the SessionFactory associated to the type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.CreateSession(System.Type)">
            <summary>
            Creates a session for the associated type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.ReleaseSession(NHibernate.ISession)">
            <summary>
            Releases the specified session
            </summary>
            <param name="session"></param>
        </member>
        <member name="E:Castle.ActiveRecord.Framework.ISessionFactoryHolder.OnRootTypeRegistered">
            <summary>
            Raised when a new root type is registered. 
            A new root type creates a new <c>ISessionFactory</c>
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.ISessionFactoryHolder.ThreadScopeInfo">
            <summary>
            Gets or sets the implementation of <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo"/>
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.SessionFactoryHolder">
            <summary>
            Default implementation of <seealso cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder"/>
            </summary>
            <remarks>
            This class is thread safe
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SessionFactoryHolder.GetAllConfigurations">
            <summary>
            Pendent
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SessionFactoryHolder.GetSessionFactory(System.Type)">
            <summary>
            Optimized with reader/writer lock.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.SupportingUtils">
            <summary>
            Usefull for external frameworks
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ValidationException.ValidationErrorMessages">
            <summary>
            Returns a list of current validation errors messages, if available.
            </summary>
        </member>
    </members>
</doc>
